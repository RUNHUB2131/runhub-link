---
description: 
globs: 
alwaysApply: true
---
# You are my senior developer and full stack engineer

This document is an overview of the project and rules and context for the project and how to build it. Please refer to this in full.

Application Overview
RUNHUB Connect is a SaaS platform that facilitates partnerships between running clubs and brands for sponsorship opportunities. The platform has two primary user types:
Run Clubs: Create profiles, browse sponsorship opportunities, and apply for partnerships
Brands: Create company profiles, post sponsorship opportunities, and review applications

Technical Stack & Architecture

Core Technologies
Frontend: React 18 + TypeScript + Vite
UI Framework: shadcn/ui (Radix UI components) + Tailwind CSS
Database: Supabase (PostgreSQL with real-time capabilities)
Authentication: Supabase Auth
State Management: React Query (@tanstack/react-query)
Routing: React Router DOM v6
Form Handling: React Hook Form with Zod validation
Styling: Tailwind CSS with animations

Project structure
src/
├── components/          # Reusable UI components organized by feature
│   ├── ui/             # Base shadcn/ui components
│   ├── layout/         # Layout components (AppLayout, AuthLayout, ProtectedRoute)
│   ├── opportunities/  # Opportunity-related components
│   ├── applications/   # Application management components
│   ├── profile/        # Profile components
│   ├── dashboard/      # Dashboard components
│   ├── chat/          # Chat/messaging components
│   └── notifications/ # Notification components
├── pages/              # Route components
├── hooks/              # Custom React hooks
├── contexts/           # React contexts (AuthContext)
├── services/           # API service layers
├── types/              # TypeScript type definitions
├── utils/              # Utility functions
├── lib/                # Library configurations
└── integrations/       # Third-party integrations (Supabase)

Database Schema & Data Models

Core Tables
-profiles: Base user profiles with user_type ('run_club' | 'brand')
-run_club_profiles: Extended profiles for running clubs
-brand_profiles: Extended profiles for brands
-opportunities: Brand-posted sponsorship opportunities
-applications: Run club applications to opportunities
-notifications: System notifications
-chats/messages: Chat functionality between brands and clubs

Key Relationships
-profiles (1:1) → run_club_profiles/brand_profiles
-brand_profiles (1:many) → opportunities
-opportunities (1:many) → applications
-run_club_profiles (1:many) → applications
-applications trigger notifications

Business Logic & User Flows

Run Club User Journey
1. Register → Select "Run Club" type → Complete profile
2. Browse available opportunities → Apply to relevant ones
3. Manage applications → Chat with brands → Track status

Brand User Journey
1. Register → Select "Brand" type → Complete company profile
2. Create sponsorship opportunities → Review applications
3. Accept/reject applications → Chat with clubs → Manage partnerships

Key Business Rules
1. Profile completion required before applying to opportunities
2. Run clubs can only see opportunities they haven't applied to
3. Brands can only see applications for their own opportunities
4. Row-level security (RLS) enforces data access permissions
5. Real-time notifications for new applications

Feature Areas

Authentication & Profiles
1. Supabase Auth with email/password
2. User type selection during registration
3. Comprehensive profile forms with validation
4. Social media integration fields
5. Logo/image upload capabilities

Opportunities Management
1. Rich opportunity creation forms for brands
2. Filtering and search capabilities
3. Deadline and geographic targeting
4. Club size and reach preferences

Applications System
1. Status tracking (pending/accepted/rejected)
2. Bulk application management for brands
3. Integration with notification system

Chat/Messaging
1. Real-time chat between brands and clubs
2. Context-aware messaging (opportunity-specific)
3. Message history and threading

Code Patterns & Conventions

Component Structure
1. Functional components with hooks
2. Props interfaces defined for all components
3. Separation of concerns (presentation vs. logic)
4. Custom hooks for data fetching and business logic

Data fetching patterns

// Use React Query for caching and state management
const { data, isLoading, error } = useQuery({
  queryKey: ['opportunities', filters],
  queryFn: () => fetchOpportunities(filters)
});

// Supabase queries with proper error handling
const { data, error } = await supabase
  .from('table_name')
  .select('columns')
  .eq('field', value);

Type Safety
1. Comprehensive TypeScript interfaces for all data models
2. Database types generated from Supabase schema
3. Props interfaces for all components
4. Utility types for common patterns

AI Assistant Guidelines

When Working with This Codebase:
1. Follow Existing Patterns
    - Use functional components with hooks
    - Implement proper TypeScript typing
    - Follow the established folder structure
    - Use existing UI components from shadcn/ui
2. Database Operations
    - Always consider RLS policies when suggesting database queries
    - Use proper error handling for Supabase operations
    - Consider real-time subscriptions for live data
    - Validate data before database operations
3.User Experience Considerations
    - Ensure profile completion checks before critical actions
    - Implement proper loading states and error handling
    - Consider user type-specific functionality
    - Maintain consistent navigation patterns
4. Security & Permissions
    - Respect user type restrictions (run_club vs brand)
    - Implement proper authentication checks
    - Consider data privacy in queries
    - Follow RLS policy patterns
5. Code Quality
    - Use React Query for data fetching and caching
    - Implement proper error boundaries
    - Use TypeScript strictly
    - Follow accessibility best practices
    - Implement responsive design patterns

Common Tasks & Approaches
1. New features: Follow feature-based folder structure
2. API changes: Update types first, then implementations
3. UI components: Extend shadcn/ui components consistently
4. Database changes: Create migrations and update TypeScript types
5. Authentication: Use existing AuthContext patterns

Performance Considerations
1. Use React Query for efficient data caching
2. Implement proper pagination for large data sets
3. Optimize Supabase queries with proper indexes
4. Use loading skeletons for better UX
5. Implement error boundaries for robust error handling
6. Utilise docker and local database




